#!/usr/bin/env python3

import gi
import subprocess
import threading
import gettext
import locale
import os
import shlex
import tempfile
import time

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw, GLib, Gdk

# --- Localization Setup ---
APP_NAME = "davinci-installer"
LOCALE_DIR = os.path.abspath("/usr/share/locale")

# Set up the locale environment
try:
    locale.setlocale(locale.LC_ALL, '')
    locale.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.textdomain(APP_NAME)
except locale.Error as e:
    print(f"Warning: Could not set locale: {e}")
_ = gettext.gettext
# --------------------------


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app)
        # App info and state
        self.set_title(_("Desktop Mode Selector"))
        self.set_default_size(600, 400)
        self.install_started = False
        self.error_message = None
        self.page_names = ["Desktop 1", "Desktop 2", "Desktop 3"]
        
        # --- Paths for scripts ---
        self.script_base_path = "/usr/share/linexin/linexin-desktop/"
        self.script_paths = {
            "Desktop 1": os.path.join(self.script_base_path, "default.sh"),
            "Desktop 2": os.path.join(self.script_base_path, "windowish.sh"),
            "Desktop 3": os.path.join(self.script_base_path, "gnome.sh"),
        }

        # --- Main Layout ---
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        # Adwaita header bar
        self.header_bar = Adw.HeaderBar()
        self.header_bar.set_title_widget(Adw.WindowTitle.new(self.get_title(), ""))
        main_box.append(self.header_bar)

        # --- Add CSS for transparent header ---
        css_provider = Gtk.CssProvider()
        css = """
        headerbar {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Main content area with arrows and stack
        content_hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12,
                               margin_top=20, margin_bottom=20, margin_start=20, margin_end=20)
        content_hbox.set_vexpand(True)
        main_box.append(content_hbox)

        # --- Navigation Buttons ---
        self.btn_prev = Gtk.Button.new_from_icon_name("go-previous-symbolic")
        self.btn_prev.set_valign(Gtk.Align.CENTER)
        self.btn_prev.connect("clicked", self.on_prev_clicked)
        content_hbox.append(self.btn_prev)

        # --- Content Stack ---
        self.content_stack = Gtk.Stack()
        self.content_stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        self.content_stack.set_hexpand(True)
        self.content_stack.set_vexpand(True)
        content_hbox.append(self.content_stack)

        self.btn_next = Gtk.Button.new_from_icon_name("go-next-symbolic")
        self.btn_next.set_valign(Gtk.Align.CENTER)
        self.btn_next.connect("clicked", self.on_next_clicked)
        content_hbox.append(self.btn_next)
        
        # Reworked stack pages to show images
        image_paths = [
            "/usr/share/linexin/desktop-mode/desktop1.png",
            "/usr/share/linexin/desktop-mode/desktop2.png",
            "/usr/share/linexin/desktop-mode/desktop1.png" # Assuming this is a placeholder
        ]

        for i, page_name in enumerate(self.page_names):
            image = Gtk.Image()
            image_path = image_paths[i]
            if os.path.exists(image_path):
                image.set_from_file(image_path)
            else:
                image.set_from_icon_name("image-missing-symbolic")
                image.set_pixel_size(128)
            
            image.set_vexpand(True)
            image.set_hexpand(True)
            self.content_stack.add_named(image, page_name)

        # Installation button is now at the bottom of the main window
        self.btn_start_install = Gtk.Button(label=_("Apply Setting"))
        self.btn_start_install.add_css_class("suggested-action")
        self.btn_start_install.connect("clicked", self.on_install_clicked)
        self.btn_start_install.set_margin_start(20)
        self.btn_start_install.set_margin_end(20)
        self.btn_start_install.set_margin_bottom(20)
        main_box.append(self.btn_start_install)

        # --- Final Setup ---
        self.content_stack.set_visible_child_name(self.page_names[0])
        self.content_stack.connect("notify::visible-child", self.update_ui_for_page_change)
        self.connect("close-request", self.on_close_request)
        self.update_ui_for_page_change()

    ### --- UI Update and Navigation Logic --- ###

    def on_prev_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index > 0:
            self.content_stack.set_visible_child_name(self.page_names[current_index - 1])

    def on_next_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index < len(self.page_names) - 1:
            self.content_stack.set_visible_child_name(self.page_names[current_index + 1])

    def update_ui_for_page_change(self, *args):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        
        if not self.install_started:
            self.btn_prev.set_sensitive(current_index > 0)
            self.btn_next.set_sensitive(current_index < len(self.page_names) - 1)
            self.btn_prev.set_opacity(1.0 if current_index > 0 else 0.3)
            self.btn_next.set_opacity(1.0 if current_index < len(self.page_names) - 1 else 0.3)

    ### --- Installation and Restore Logic --- ###
    
    def on_close_request(self, *args):
        if self.install_started:
            dialog = Adw.MessageDialog(heading=_("Operation in Progress"), body=_("Please wait for the current operation to finish."), transient_for=self, modal=True)
            dialog.add_response("ok", _("OK"))
            dialog.present()
            return True
        return False

    def on_install_clicked(self, button):
        """Shows a confirmation dialog before running the script."""
        selected_desktop = self.content_stack.get_visible_child_name()
        script_to_run = self.script_paths.get(selected_desktop)

        dialog = Adw.MessageDialog(
            heading=_("Run Script?"),
            body=_("This will apply settings for {}.\n\nThis may change your system settings. Do you want to continue?").format(selected_desktop),
            transient_for=self,
            modal=True
        )
        dialog.add_response("cancel", _("Cancel"))
        dialog.add_response("run", _("Run"))
        dialog.set_response_appearance("run", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        dialog.connect("response", self.on_confirmation_response, script_to_run, selected_desktop)
        dialog.present()

    def on_confirmation_response(self, dialog, response_id, script_path, desktop_name):
        """Checks for the script and starts the execution process."""
        if response_id != "run":
            return

        if not script_path:
            self.show_info_dialog(_("Error"), _("No script is defined for {}.").format(desktop_name))
            return

        # Check if the script exists and is executable
        if not os.path.exists(script_path):
            self.show_info_dialog(_("Error"), _("Script not found at:\n{}").format(script_path))
            return
        if not os.access(script_path, os.X_OK):
            self.show_info_dialog(_("Error"), _("Script is not executable:\n{}").format(script_path))
            return
            
        self.begin_install(script_path, desktop_name)

    def begin_install(self, script_path, product_name):
        """Disables UI and starts the script execution thread."""
        self.error_message = None
        self.install_started = True
        
        self.header_bar.set_sensitive(False)
        self.btn_prev.set_sensitive(False)
        self.btn_next.set_sensitive(False)
        self.btn_prev.set_opacity(0.3)
        self.btn_next.set_opacity(0.3)
        self.btn_start_install.set_sensitive(False)
        self.btn_start_install.set_label(_("Applying..."))
        
        self.current_product = product_name
        
        threading.Thread(target=self.run_shell_script, args=(script_path,), daemon=True).start()

    def run_shell_script(self, script_path):
        """Executes the specified bash script twice in a row with a delay."""
        try:
            # Loop to run the script twice
            for i in range(2):
                # Add a 1-second delay before the second run
                if i == 1:
                    time.sleep(1)

                command = ['/bin/bash', script_path]
                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                stdout, stderr = process.communicate()
                return_code = process.returncode

                # If a run fails, stop and report the error immediately.
                if return_code != 0:
                    self.error_message = _("Script failed on run #{0} with code {1}.\n\nDetails: {2}").format(i + 1, return_code, stderr.strip())
                    break  # Exit the loop on failure
            
            # If the loop completed without breaking, error_message is still None.

        except Exception as e:
            self.error_message = _("An unexpected error occurred while running the script: {}").format(str(e))
        
        GLib.idle_add(self.finish_installation)

    def finish_installation(self):
        """Called on the main thread after the script finishes to update UI."""
        self.install_started = False
        
        self.header_bar.set_sensitive(True)
        self.btn_start_install.set_sensitive(True)
        self.btn_start_install.set_label(_("Apply Setting"))
        
        self.update_ui_for_page_change()

        if self.error_message:
            dialog_heading = _("Operation Failed")
            dialog_body = _("Could not apply style for {}.\n\nError: {}").format(self.current_product, self.error_message)
        else:
            dialog_heading = _("Operation Successful")
            dialog_body = _("Successfully applied style for {}.").format(self.current_product)

        self.show_info_dialog(dialog_heading, dialog_body)
        
        return GLib.SOURCE_REMOVE

    def show_info_dialog(self, heading, body):
        dialog = Adw.MessageDialog(
            heading=heading,
            body=body,
            transient_for=self,
            modal=True
        )
        dialog.add_response("ok", _("OK"))
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        dialog.present()

class DaVinciApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="github.petexy.desktop.selector")

    def do_activate(self):
        win = MainWindow(self)
        win.present()

if __name__ == "__main__":
    import sys
    app = DaVinciApp()
    sys.exit(app.run(sys.argv))
