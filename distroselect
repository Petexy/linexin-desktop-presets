#!/usr/bin/env python3

import gi
import subprocess
import threading
import gettext
import locale
import os
import shlex
import tempfile
import time

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw, GLib, Gdk

# --- Localization Setup ---
APP_NAME = "davinci-installer"
LOCALE_DIR = os.path.abspath("/usr/share/locale")

# Set up the locale environment
try:
    locale.setlocale(locale.LC_ALL, '')
    locale.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.textdomain(APP_NAME)
except locale.Error as e:
    print(f"Warning: Could not set locale: {e}")
_ = gettext.gettext
# --------------------------


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app)
        # App info and state
        self.set_title(_("Desktop Mode Selector"))
        self.set_default_size(600, 400)
        self.install_started = False
        self.error_message = None
        self.page_names = ["Desktop 1", "Desktop 2", "Desktop 3"]
        
        # --- Paths for scripts ---
        self.script_base_path = "/usr/share/linexin/linexin-desktop/"
        # Correctly defined path for the monitor script
        self.monitor_script_path = "/usr/share/linexin/linexin-desktop/update-monitor.sh"
        self.script_paths = {
            "Desktop 1": os.path.join(self.script_base_path, "default.sh"),
            "Desktop 2": os.path.join(self.script_base_path, "windowish.sh"),
            "Desktop 3": os.path.join(self.script_base_path, "gnome.sh"),
        }

        # --- Main Layout ---
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        # Adwaita header bar
        self.header_bar = Adw.HeaderBar()
        self.header_bar.set_title_widget(Adw.WindowTitle.new(self.get_title(), ""))
        main_box.append(self.header_bar)

        # --- Add CSS for transparent header ---
        css_provider = Gtk.CssProvider()
        css = """
        headerbar {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Main content area with arrows and stack
        content_hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12,
                               margin_top=20, margin_bottom=20, margin_start=20, margin_end=20)
        content_hbox.set_vexpand(True)
        main_box.append(content_hbox)

        # --- Navigation Buttons ---
        self.btn_prev = Gtk.Button.new_from_icon_name("go-previous-symbolic")
        self.btn_prev.set_valign(Gtk.Align.CENTER)
        self.btn_prev.connect("clicked", self.on_prev_clicked)
        content_hbox.append(self.btn_prev)

        # --- Content Stack ---
        self.content_stack = Gtk.Stack()
        self.content_stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        self.content_stack.set_hexpand(True)
        self.content_stack.set_vexpand(True)
        content_hbox.append(self.content_stack)

        self.btn_next = Gtk.Button.new_from_icon_name("go-next-symbolic")
        self.btn_next.set_valign(Gtk.Align.CENTER)
        self.btn_next.connect("clicked", self.on_next_clicked)
        content_hbox.append(self.btn_next)
        
        # Reworked stack pages to show images
        image_paths = [
            "/usr/share/linexin/desktop-mode/desktop1.png",
            "/usr/share/linexin/desktop-mode/desktop2.png",
            "/usr/share/linexin/desktop-mode/desktop1.png" # Assuming this is a placeholder
        ]

        for i, page_name in enumerate(self.page_names):
            image = Gtk.Image()
            image_path = image_paths[i]
            if os.path.exists(image_path):
                image.set_from_file(image_path)
            else:
                image.set_from_icon_name("image-missing-symbolic")
                image.set_pixel_size(128)
            
            image.set_vexpand(True)
            image.set_hexpand(True)
            self.content_stack.add_named(image, page_name)

        # Installation button is now at the bottom of the main window
        self.btn_start_install = Gtk.Button(label=_("Apply Setting"))
        self.btn_start_install.add_css_class("suggested-action")
        self.btn_start_install.connect("clicked", self.on_install_clicked)
        self.btn_start_install.set_margin_start(20)
        self.btn_start_install.set_margin_end(20)
        self.btn_start_install.set_margin_bottom(20)
        main_box.append(self.btn_start_install)

        # --- Final Setup ---
        self.content_stack.set_visible_child_name(self.page_names[0])
        self.content_stack.connect("notify::visible-child", self.update_ui_for_page_change)
        self.connect("close-request", self.on_close_request)
        self.update_ui_for_page_change()

    ### --- UI Update and Navigation Logic --- ###

    def on_prev_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index > 0:
            self.content_stack.set_visible_child_name(self.page_names[current_index - 1])

    def on_next_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index < len(self.page_names) - 1:
            self.content_stack.set_visible_child_name(self.page_names[current_index + 1])

    def update_ui_for_page_change(self, *args):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        
        if not self.install_started:
            self.btn_prev.set_sensitive(current_index > 0)
            self.btn_next.set_sensitive(current_index < len(self.page_names) - 1)
            self.btn_prev.set_opacity(1.0 if current_index > 0 else 0.3)
            self.btn_next.set_opacity(1.0 if current_index < len(self.page_names) - 1 else 0.3)

    ### --- Installation and Restore Logic --- ###
    
    def on_close_request(self, *args):
        if self.install_started:
            dialog = Adw.MessageDialog(heading=_("Operation in Progress"), body=_("Please wait for the current operation to finish."), transient_for=self, modal=True)
            dialog.add_response("ok", _("OK"))
            dialog.present()
            return True
        return False

    def on_install_clicked(self, button):
        """Shows a confirmation dialog before running the script."""
        selected_desktop = self.content_stack.get_visible_child_name()
        script_to_run = self.script_paths.get(selected_desktop)

        dialog = Adw.MessageDialog(
            heading=_("Run Script?"),
            body=_("This will apply settings for {}.\n\nThis may change your system settings. Do you want to continue?").format(selected_desktop),
            transient_for=self,
            modal=True
        )
        dialog.add_response("cancel", _("Cancel"))
        dialog.add_response("run", _("Run"))
        dialog.set_response_appearance("run", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        dialog.connect("response", self.on_confirmation_response, script_to_run, selected_desktop)
        dialog.present()

    def on_confirmation_response(self, dialog, response_id, script_path, desktop_name):
        """Checks for the script and starts the execution process."""
        if response_id != "run":
            return

        if not script_path or not os.path.exists(script_path) or not os.access(script_path, os.X_OK):
            self.show_info_dialog(_("Error"), _("Main script not found or is not executable:\n{}").format(script_path))
            return
        
        if not os.path.exists(self.monitor_script_path) or not os.access(self.monitor_script_path, os.X_OK):
            self.show_info_dialog(_("Error"), _("Monitor script not found or is not executable:\n{}").format(self.monitor_script_path))
            return
            
        self.begin_install(script_path, desktop_name)

    def begin_install(self, script_path, product_name):
        """Disables UI and starts the multi-step script execution thread."""
        self.error_message = None
        self.install_started = True
        
        self.header_bar.set_sensitive(False)
        self.btn_prev.set_sensitive(False)
        self.btn_next.set_sensitive(False)
        self.btn_prev.set_opacity(0.3)
        self.btn_next.set_opacity(0.3)
        self.btn_start_install.set_sensitive(False)
        
        # Start with the first step: updating the display
        self.btn_start_install.set_label(_("Updating display..."))
        
        self.current_product = product_name
        
        # The chain starts here, passing the main script path for later use
        threading.Thread(target=self.task_run_monitor_script, args=(script_path,), daemon=True).start()

    def task_run_monitor_script(self, main_script_path_for_next_step):
        """TASK 1: Executes the monitor update script in a background thread."""
        try:
            command = ['/bin/bash', self.monitor_script_path]
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate()

            if process.returncode != 0:
                self.error_message = _("Monitor script failed with code {0}.\n\nDetails: {1}").format(process.returncode, stderr.strip())
        
        except Exception as e:
            self.error_message = _("An error occurred during monitor update: {}").format(str(e))

        # This will call the next step on the main GTK thread
        GLib.idle_add(self.on_monitor_script_done, main_script_path_for_next_step)
        
    def on_monitor_script_done(self, main_script_path):
        """UI THREAD: Checks result of monitor script and starts main script if successful."""
        if self.error_message:
            # If the monitor script failed, stop here and show the error.
            self.finalize_ui()
        else:
            # Monitor script succeeded. Proceed to the main style script.
            self.btn_start_install.set_label(_("Applying settings..."))
            threading.Thread(target=self.task_run_main_script, args=(main_script_path,), daemon=True).start()
        
        return GLib.SOURCE_REMOVE

    def task_run_main_script(self, script_path):
        """TASK 2: Executes the main settings script in a background thread."""
        try:
            command = ['/bin/bash', script_path]
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                self.error_message = _("Main script failed with code {0}.\n\nDetails: {1}").format(process.returncode, stderr.strip())
        
        except Exception as e:
            self.error_message = _("An unexpected error occurred while running the main script: {}").format(str(e))
        
        # This will call the final UI update on the main GTK thread
        GLib.idle_add(self.finalize_ui)

    def finalize_ui(self):
        """UI THREAD: Called after all operations are complete to update the UI."""
        self.install_started = False
        
        self.header_bar.set_sensitive(True)
        self.btn_start_install.set_sensitive(True)
        self.btn_start_install.set_label(_("Apply Setting"))
        
        self.update_ui_for_page_change()

        if self.error_message:
            dialog_heading = _("Operation Failed")
            dialog_body = _("Could not apply style for {}.\n\nError: {}").format(self.current_product, self.error_message)
        else:
            dialog_heading = _("Operation Successful")
            dialog_body = _("Successfully applied style for {}.").format(self.current_product)

        self.show_info_dialog(dialog_heading, dialog_body)
        
        return GLib.SOURCE_REMOVE

    def show_info_dialog(self, heading, body):
        dialog = Adw.MessageDialog(
            heading=heading,
            body=body,
            transient_for=self,
            modal=True
        )
        dialog.add_response("ok", _("OK"))
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        dialog.present()

class DaVinciApp(Adw.Application):
    def __init__(self):
        super().__init__(application_id="github.petexy.desktop.selector")

    def do_activate(self):
        win = MainWindow(self)
        win.present()

if __name__ == "__main__":
    import sys
    app = DaVinciApp()
    sys.exit(app.run(sys.argv))