#!/usr/bin/env python3

import gi
import subprocess
import threading
import gettext
import locale
import os
import shlex
import tempfile
import time

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk, Adw, GLib, Gdk

# --- Localization Setup ---
APP_NAME = "linexin-desktop-presets"
LOCALE_DIR = os.path.abspath("/usr/share/locale")

# Set up the locale environment
try:
    locale.setlocale(locale.LC_ALL, '')
    locale.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.bindtextdomain(APP_NAME, LOCALE_DIR)
    gettext.textdomain(APP_NAME)
except locale.Error as e:
    print(f"Warning: Could not set locale: {e}")
_ = gettext.gettext
# --------------------------


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, app):
        super().__init__(application=app)
        # App info and state
        self.set_title(_("Select your design"))
        self.set_default_size(1280, 850)
        self.install_started = False
        self.error_message = None
        # --- MODIFIED: Updated the page names as requested ---
        self.page_names = ["Linexin", "Winexin", "Ubunexin", "Pure GNOME",]
        
        # --- Use os.path.expanduser to correctly resolve home directory ---
        home_dir = os.path.expanduser('~')
        
        self.script_base_path = os.path.join(home_dir, ".local/share/linexin/linexin-desktop/")
        image_base_path = os.path.join(home_dir, ".local/share/linexin/linexin-desktop/")

        self.monitor_script_path = os.path.join(self.script_base_path, "update-monitor.sh")
        self.script_paths = {
            "Linexin": os.path.join(self.script_base_path, "default.sh"),
            "Winexin": os.path.join(self.script_base_path, "windowish.sh"),
            "Ubunexin": os.path.join(self.script_base_path, "ubunexin.sh"),
            "Pure GNOME": os.path.join(self.script_base_path, "gnome.sh"),
        }

        # --- Main Layout ---
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_content(main_box)

        self.header_bar = Adw.HeaderBar()
        self.header_bar.set_title_widget(Adw.WindowTitle.new(self.get_title(), ""))
        main_box.append(self.header_bar)

        css_provider = Gtk.CssProvider()
        css = """
        headerbar {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
        """
        css_provider.load_from_data(css.encode())
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # --- Set spacing equal to margins for a symmetrical layout ---
        content_hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12,
                               margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)
        content_hbox.set_vexpand(True)
        main_box.append(content_hbox)

        self.btn_prev = Gtk.Button.new_from_icon_name("go-previous-symbolic")
        self.btn_prev.set_valign(Gtk.Align.CENTER)
        self.btn_prev.connect("clicked", self.on_prev_clicked)
        content_hbox.append(self.btn_prev)

        self.content_stack = Gtk.Stack()
        self.content_stack.set_transition_type(Gtk.StackTransitionType.SLIDE_LEFT_RIGHT)
        self.content_stack.set_hexpand(True)
        self.content_stack.set_vexpand(True)
        content_hbox.append(self.content_stack)

        self.btn_next = Gtk.Button.new_from_icon_name("go-next-symbolic")
        self.btn_next.set_valign(Gtk.Align.CENTER)
        self.btn_next.connect("clicked", self.on_next_clicked)
        content_hbox.append(self.btn_next)
        
        # --- Use Gtk.Picture for scaling ---
        image_paths = [
            os.path.join(image_base_path, "default.png"),
            os.path.join(image_base_path, "windowish.png"),
            os.path.join(image_base_path, "ubunexin.png"),
            os.path.join(image_base_path, "gnome.png")
        ]

        for i, page_name in enumerate(self.page_names):
            image_path = image_paths[i]
            
            # This Box will hold the picture and the label vertically
            page_container = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
            page_container.set_valign(Gtk.Align.CENTER)

            # Create the Picture widget for the image
            picture = Gtk.Picture()
            picture.set_keep_aspect_ratio(True)
            picture.set_can_shrink(True)
            picture.set_vexpand(True)
            picture.set_hexpand(True)

            if os.path.exists(image_path):
                picture.set_filename(image_path)
            
            # Create a Label for the text
            label = Gtk.Label(label=page_name)
            # Use a built-in Adwaita style for a nice heading look
            label.add_css_class("title-3")

            # Add the picture and label to their container
            page_container.append(picture)
            page_container.append(label)
            
            # Add the container to the stack as a page
            self.content_stack.add_named(page_container, page_name)

        self.btn_start_install = Gtk.Button(label=_("Apply style"))
        self.btn_start_install.add_css_class("suggested-action")
        self.btn_start_install.connect("clicked", self.on_install_clicked)
        self.btn_start_install.set_margin_start(300)
        self.btn_start_install.set_margin_end(300)
        self.btn_start_install.set_margin_bottom(20)
        self.btn_start_install.set_vexpand(True)
        main_box.append(self.btn_start_install)

        self.content_stack.set_visible_child_name(self.page_names[0])
        self.content_stack.connect("notify::visible-child", self.update_ui_for_page_change)
        self.connect("close-request", self.on_close_request)
        self.update_ui_for_page_change()

    ### --- UI Update and Navigation Logic --- ###

    def on_prev_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index > 0:
            self.content_stack.set_visible_child_name(self.page_names[current_index - 1])

    def on_next_clicked(self, button):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        if current_index < len(self.page_names) - 1:
            self.content_stack.set_visible_child_name(self.page_names[current_index + 1])

    def update_ui_for_page_change(self, *args):
        current_name = self.content_stack.get_visible_child_name()
        current_index = self.page_names.index(current_name)
        
        if not self.install_started:
            self.btn_prev.set_sensitive(current_index > 0)
            self.btn_next.set_sensitive(current_index < len(self.page_names) - 1)
            self.btn_prev.set_opacity(1.0 if current_index > 0 else 0.3)
            self.btn_next.set_opacity(1.0 if current_index < len(self.page_names) - 1 else 0.3)

    ### --- Installation and Restore Logic --- ###
    
    def on_close_request(self, *args):
        if self.install_started:
            dialog = Adw.MessageDialog(heading=_("Operation in Progress"), body=_("Please wait for the current operation to finish."), transient_for=self, modal=True)
            dialog.add_response("ok", _("OK"))
            dialog.present()
            return True
        return False

    def on_install_clicked(self, button):
        """Validates scripts and starts the installation process directly."""
        selected_desktop = self.content_stack.get_visible_child_name()
        script_to_run = self.script_paths.get(selected_desktop)

        # Perform validation checks
        if not script_to_run or not os.path.exists(script_to_run) or not os.access(script_to_run, os.X_OK):
            self.show_info_dialog(_("Error"), _("Main script not found or is not executable:\n{}").format(script_to_run))
            return
        
        if not os.path.exists(self.monitor_script_path) or not os.access(self.monitor_script_path, os.X_OK):
            self.show_info_dialog(_("Error"), _("Monitor script not found or is not executable:\n{}").format(self.monitor_script_path))
            return
        
        # If all checks pass, begin the process immediately.
        self.begin_install(script_to_run, selected_desktop)

    def begin_install(self, script_path, product_name):
        """Disables UI and starts the multi-step script execution thread."""
        self.error_message = None
        self.install_started = True
        
        self.header_bar.set_sensitive(False)
        self.btn_prev.set_sensitive(False)
        self.btn_next.set_sensitive(False)
        self.btn_prev.set_opacity(0.3)
        self.btn_next.set_opacity(0.3)
        self.btn_start_install.set_sensitive(False)
        
        self.btn_start_install.set_label(_("Updating display..."))
        
        self.current_product = product_name
        
        threading.Thread(target=self.task_run_monitor_script, args=(script_path,), daemon=True).start()

    def task_run_monitor_script(self, main_script_path_for_next_step):
        """TASK 1: Executes the monitor update script in a background thread."""
        try:
            command = ['/bin/bash', self.monitor_script_path]
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            stdout, stderr = process.communicate()

            if process.returncode != 0:
                self.error_message = _("Monitor script failed with code {0}.\n\nDetails: {1}").format(process.returncode, stderr.strip())
        
        except Exception as e:
            self.error_message = _("An error occurred during monitor update: {}").format(str(e))

        GLib.idle_add(self.on_monitor_script_done, main_script_path_for_next_step)
        
    def on_monitor_script_done(self, main_script_path):
        """UI THREAD: Checks result of monitor script and starts main script if successful."""
        if self.error_message:
            self.finalize_ui()
        else:
            self.btn_start_install.set_label(_("Applying settings..."))
            threading.Thread(target=self.task_run_main_script, args=(main_script_path,), daemon=True).start()
        
        return GLib.SOURCE_REMOVE

    def task_run_main_script(self, script_path):
        """TASK 2: Executes the main settings script twice, with a delay."""
        try:
            for i in range(2):
                if i > 0:
                    time.sleep(1)

                command = ['/bin/bash', script_path]
                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                stdout, stderr = process.communicate()
                
                if process.returncode != 0:
                    self.error_message = _("Main script failed on run #{0} with code {1}.\n\nDetails: {2}").format(i + 1, process.returncode, stderr.strip())
                    break
        
        except Exception as e:
            self.error_message = _("An unexpected error occurred while running the main script: {}").format(str(e))
        
        GLib.idle_add(self.finalize_ui)

    def finalize_ui(self):
        """UI THREAD: Called after all operations are complete to update the UI."""
        self.install_started = False
        
        self.header_bar.set_sensitive(True)
        self.btn_start_install.set_sensitive(True)
        self.btn_start_install.set_label(_("Apply style"))
        
        self.update_ui_for_page_change()

        if self.error_message:
            dialog_heading = _("Operation Failed")
            dialog_body = _("Could not apply style for {}.\n\nError: {}").format(self.current_product, self.error_message)
            self.show_info_dialog(dialog_heading, dialog_body)
        else:
            pass
        
        return GLib.SOURCE_REMOVE

    def show_info_dialog(self, heading, body):
        dialog = Adw.MessageDialog(
            heading=heading,
            body=body,
            transient_for=self,
            modal=True
        )
        dialog.add_response("ok", _("OK"))
        dialog.set_default_response("ok")
        dialog.set_close_response("ok")
        dialog.present()

class LinexinDesktopPresets(Adw.Application):
    def __init__(self):
        super().__init__(application_id="github.petexy.linexin-desktop-presets")

    def do_activate(self):
        win = MainWindow(self)
        win.present()

if __name__ == "__main__":
    import sys
    app = LinexinDesktopPresets()
    sys.exit(app.run(sys.argv))